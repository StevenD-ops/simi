"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PREPROCESSORS = exports.MessagePreprocessors = void 0;
const mime_1 = __importDefault(require("mime"));
const fs_extra_1 = require("fs-extra");
const SCRUB = (message) => __awaiter(void 0, void 0, void 0, function* () {
    if (message.deprecatedMms3Url)
        return Object.assign(Object.assign({}, message), { conetnt: "", body: "" });
    return message;
});
const BODY_ONLY = (message) => __awaiter(void 0, void 0, void 0, function* () {
    if (message.deprecatedMms3Url)
        return Object.assign(Object.assign({}, message), { conetnt: "" });
    return message;
});
const AUTO_DECRYPT = (message, client) => __awaiter(void 0, void 0, void 0, function* () {
    if (message.deprecatedMms3Url)
        return Object.assign(Object.assign({}, message), { body: yield client.decryptMedia(message) });
    return message;
});
const AUTO_DECRYPT_SAVE = (message, client) => __awaiter(void 0, void 0, void 0, function* () {
    if (message.deprecatedMms3Url) {
        const filename = `${message.id.split("_").slice(-1)[0]}.${mime_1.default.extension(message.mimetype)}`;
        const mediaData = yield client.decryptMedia(message);
        const filePath = `media/${filename}`;
        try {
            fs_extra_1.outputFileSync(filePath, Buffer.from(mediaData.split(",")[1], "base64"));
        }
        catch (error) {
            console.error(error);
            return message;
        }
        return Object.assign(Object.assign({}, message), { body: filename, content: "", filePath });
    }
    return message;
});
/**
 * An object that contains all available [[PREPROCESSORS]].
 *
 * [Check out the processor code here](https://github.com/open-wa/wa-automate-nodejs/blob/master/src/structures/preProcessors.ts)
 */
exports.MessagePreprocessors = {
    AUTO_DECRYPT_SAVE,
    AUTO_DECRYPT,
    BODY_ONLY,
    SCRUB,
};
/**
 * A set of easy to use, built-in message processors.
 *
 * [Check out the processor code here](https://github.com/open-wa/wa-automate-nodejs/blob/master/src/structures/preProcessors.ts)
 *
 */
var PREPROCESSORS;
(function (PREPROCESSORS) {
    /**
     * This preprocessor scrubs `body` and `content` from media messages.
     * This would be useful if you want to reduce the message object size because neither of these values represent the actual file, only the thumbnail.
     */
    PREPROCESSORS["SCRUB"] = "SCRUB";
    /**
     * A preprocessor that limits the amount of base64 data is present in the message object by removing duplication of `body` in `content` by replacing `content` with `""`.
     */
    PREPROCESSORS["BODY_ONLY"] = "BODY_ONLY";
    /**
     * Replaces the media thumbnail base64 in `body` with the actual file's DataURL.
     */
    PREPROCESSORS["AUTO_DECRYPT"] = "AUTO_DECRYPT";
    /**
     * Automatically saves the file in a folder named `/media` relative to the process working directory.
     *
     * PLEASE NOTE, YOU WILL NEED TO MANUALLY CLEAR THIS FOLDER!!!
     */
    PREPROCESSORS["AUTO_DECRYPT_SAVE"] = "AUTO_DECRYPT_SAVE";
})(PREPROCESSORS = exports.PREPROCESSORS || (exports.PREPROCESSORS = {}));
